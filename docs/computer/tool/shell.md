# shell是什么？
符号`～`说明当前的工作目录是`home`  
符号`$`表示现在的身份不是root用户  
- 查看本机shell版本`cat /etc/shells` 
- 最简单命令，执行一个程序`date`  
- 执行命令的同时向程序传递参数`echo hello`  
- 显示当前目录`pwd`  
- 路径以`/`开头表示绝对路径，其他都是相对路径，切换目录`cd \home`  
- `.`表示当前目录，`..`表示上一级目录，返回上一级目录`cd ..`  
一般来说，运行一个程序时，如果没有指定路径，则程序会在当前目录下执行。
- 查看当前目录包含哪些文件`ls`，查看目录下指定后缀文件`ls *.sh`  
大多数的命令接受标记和选项，它们以-开头，并可以改变程序的行为。通常，在执行程序时使用`-h`或`--help`标记可以打印帮助信息，以便可以了解又哪些可用的标记或选项，例如`ls --help`  
- 查看指定目录文件详情`ls -l /home`  
- 查看命令手册`man ls`,按q退出。
    - `man ascii`: 查看ASCII字符码
- 重命名或移动文件`mv`  
- 拷贝文件`cp`  
- 新建文件夹`mkdir <文件夹名>`，删除文件夹`rmdir <文件夹名>`
- 新建文件`touch <文件名>`，删除文件`rm 文件名` ，删除文件夹的另一种方式`rm -rf 目录名字`  
`-r` 就是向下递归，不管有多少级目录，一并删除,`-f`就是直接强行删除，不作任何提示的意思
- 输出到指定文件`echo hello > hello.txt`  
- 从指定文件输入`cat < hello.txt`
- 向文件中追加内容（在文件原有的内容上续写）`>>`  
- |操作符允许我们将一个程序的输出和另外一个程序的输入链接起`ls -l / | tail -nl`
`sudo`命令，以root的身份执行操作，当遇到`permission denied`的错误时，通常是因为此时必须是根用户才能操作。

# Shell工具和脚本
- 变量赋值`foo=bar`  
- 打印变量`echo $foo` or `echo "$foo"`,单引号是原义字符串，其中的变量不会被转义,`echo '$foo'`，上述命令将只会打印——$foo字符串  

- 加载一个函数`source mcd.sh`，执行它`mcd test`

### [特殊变量](https://tldp.org/LDP/abs/html/special-chars.html)
- `$0` -脚本名
- `$1`到`$9` -脚本参数
- `$@` -所有参数
- `$？` -前一个命令返回值,`0`表示no errors，类似C/C++函数中最后一条语句`return 0；`（bool运算中true=1,false=0）
- `$$` -当前脚本的进程识别码 
- `$_` -上一条命了的最后一个参数
- `$#` -给命令行的参数
- `!!` -完整的上一条指令，包括参数。常见应用：当因为权限不足，执行命令失败时，可以使用`sudo !!`再尝试一次

- 搜索`grep`

#### `||`或链接符
- `false || echo "Oops fail"`这里是由或运算符链接的两条语句，如果第一条语句失败，则执行第二条一句
- `true || echo "Will be not be printed"`,第一条语句执行成功，第二条语句不执行
#### `&&`与链接符
- `true && echo "Things went well"`,第一条语句执行成功，第二条语句执行
- `false && echo "This will not print"`,第一条语句执行失败，第二条语句不执行
#### `;`分号链接符
- `false ; echo "This will always print"`,两条语句将依次执行

- 将返回结果赋值给变量`foo=$(pwd)`，更近一步，还可以这样做`echo "We are in $(pwd)"`

- `cat` 读取并显示文件内容

- 转换文件格式`convert image.png image.jpg`

#### 通配符`?`和`*`
当你想要利用通配符进行匹配时，你可以分别使用 ? 和 * 来匹配一个或任意个字符。例如，对于文件foo, foo1, foo2, foo10 和 bar, rm foo?这条命令会删除foo1 和 foo2 ，而rm foo* 则会删除除了bar之外的所有文件。
#### 花括号`{}` 
当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。


#### shell函数和脚本有如下一些不同点：
- 函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 shebang 是很重要的。
- 函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。
- 函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 export 将环境变量导出，并将值传递给环境变量。
- 与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。

### shell工具
- 在上一节中我们介绍过，最常用的方法是为对应的命令行添加`-h` 或 `--help` 标记。另外一个更详细的方法则是使用man 命令。`man`命令是手册（manual）的缩写，它提供了命令的用户手册。

- 在foo和bar文件夹下分别创建a到j的文件`touch {foo,bar}/{a..j} `
- 比较两个文件夹文件的不同`diff <(ls foo) <(ls bar)`


- 检查shell脚本文件的bug`shellcheck mcd.sh`

#### 查找文件
- 查找所有名称为test的文件夹`find . -name test -type d`
- 查找所有文件夹路径中包含test的python文件`find . -path '*/test/*.python' -type f`
- 查找前一天修改的所有文件`find . -mtime -1`
- 查找所有大小在500k至10M的.cpp文件  `find . -size +500 -size -10M -name '*.cpp'`
除了列出所寻找的文件之外，find 还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。

#### 查找代码
grep
ripgrep(rg)
- 查找所有使用了requests的文件`rg -t py 'include iostream'`
- 查找所有没有写 shebang 的文件（包含隐藏文件）`rg -u --files-without-match "^#!"`
- 查找所有的foo字符串，并打印其之后的5行`rg foo -A 5`
- 打印匹配的统计信息（匹配的行和文件的数量）`rg --stats PATTERN`
#### 查找shell命令
按向上的方向键会显示使用过的上一条命令，继续按上键则会遍历整个历史记录。
#### 文件夹导航
